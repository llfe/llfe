# LLFE
[Literate programming] support for [LFE], inspired by [@mqsoh]'s [knot].

[Literate programming]: https://en.wikipedia.org/wiki/Literate_programming
[LFE]: https://github.com/rvirding/lfe
[@mqsoh]: https://github.com/mqsoh
[knot]: https://github.com/mqsoh/knot

To use LLFE globally in [fish], add something like the following
to your `config.fish`:

```{.fish name="llfe fish function"}
function llfe -d "Literate Lisp Flavoured Erlang"
  eval $HOME/src/quasiquoting/llfe/llfe $argv
end
```

[fish]: http://fishshell.com


## Script
```{.lfe name="file:llfe"}
<<shebang>>

<<generated>>

<<include libs>>

<<usage>>


<<llfe>>
```

To run LFE scripts from a shell, include the following shebang.
The second line tells Emacs to use [`lfe-mode`] when editing this file.

```{.lfe name="shebang"}
#!/usr/bin/env lfe
;;; -*- lfe -*-
```

[`lfe-mode`]: http://melpa.org/#/lfe-mode

Then add a notice that this is a literate program not to be edited directly.

```{.lfe name="generated"}
;;;===================================================================
;;; This file was generated by LLFE. Do not edit it directly.
;;; Instead, edit llfe.md and call: llfe llfe.md
;;;===================================================================
```

In order for [`modified-time/1`] to work, include [`kernel/include/file.hrl`].

```{.lfe name="include libs"}
(include-lib "kernel/include/file.hrl")
```

[`modified-time/1`]: #modified-time1
[`kernel/include/file.hrl`]: https://github.com/erlang/otp/blob/maint/lib/kernel/include/file.hrl


To make deeply nested s-expressions more manageable and easier to read,
include the threading macros in [`clj/include/compose.lfe`].

```{.lfe name="include libs"}

;; (include-lib "clj/include/compose.lfe")
(defmacro ->
  ([x]               x)
  ([x `(,f . ,body)] `(,f ,x ,@body))
  ([x sexp]          `(list ,sexp ,x))
  ([x sexp . sexps]  `(-> (-> ,x ,sexp) ,@sexps)))

(defmacro ->>
  ([x]               x)
  ([x `(,f . ,body)] `(,f ,@body ,x))
  ([x sexp]          `(list ,sexp ,x))
  ([x sexp . sexps]  `(->> (->> ,x ,sexp) ,@sexps)))
```

[`clj/include/compose.lfe`]: https://github.com/lfex/clj/blob/master/include/compose.lfe

### Usage
When the [CLI] is given invalid arguments or something `help`-like, print usage
tips to the console.

```{.text name="usage output"}
LLFE: Literate Lisp Flavoured Erlang

Usage: llfe [file]...
       llfe watch [file]...

Syntax: Literate LFE files are written in Markdown.
        For information about the syntax, please refer to:
        https://github.com/quasiquoting/llfe.

'llfe watch' takes a list of files. When a change is detected
on any of the files, llfe will automatically re-tangle them.

There are some debugging functions pertaining to the way the
parser handles documents. Their usage is as follows:

    llfe print-code [file]
    llfe print-concatenated-code [file]
    llfe print-expanded-code [file]
    llfe print-unescaped-code [file]
    llfe print-file-sections [file]

For more information, it's probably best to read the literate
source of LLFE itself.
```

```{.lfe name="usage"}
(defun usage ()
  "Print usage tips to the console."
  (io:fwrite (++ "LLFE: Literate Lisp Flavoured Erlang\n"
                 "\n"
                 "Usage: llfe [file]...\n"
                 "       llfe watch [file]...\n"
                 "\n"
                 "Syntax: Literate LFE files are written in Markdown.\n"
                 "        For information about the syntax, please refer to:\n"
                 "        https://github.com/quasiquoting/llfe.\n"
                 "\n"
                 "'llfe watch' takes a list of files. When a change is detected\n"
                 "on any of the files, llfe will automatically re-tangle them.\n"
                 "\n"
                 "There are some debugging functions pertaining to the way the\n"
                 "parser handles documents. Their usage is as follows:\n"
                 "\n"
                 "    llfe print-code [file]\n"
                 "    llfe print-concatenated-code [file]\n"
                 "    llfe print-expanded-code [file]\n"
                 "    llfe print-unescaped-code [file]\n"
                 "    llfe print-file-sections [file]\n"
                 "\n"
                 "For more information, it's probably best to read the literate\n"
                 "source of LLFE itself.\n")))
```

[CLI]: ./llfe


### Printing
```{.lfe name="printing"}
<<print-code>>

<<print-concatenated-code>>

<<print-expanded-code>>

<<print-unescaped-code>>

<<print-file-sections>>
```

As listed by `usage/0`, there are a number of debugging functions pertaining to
the way the parser handles documents. Each of the `print-*/1` functions takes
a `filename` and prints some representation of the code therein.

In every exposed `print-*/1` function, label sections by `name` and print them.

```{.lfe name="printing"}

(defun print-sections (sections)
  "Label and print each `` `#(,name ,code) `` in `sections`."
  (lists:foreach
    (lambda (name-code)
      (io:fwrite "~s~n-----~n~s~n-----~n~n" (tuple_to_list name-code)))
    sections))
```

#### print-code/1
Parse a literate LFE file and print each code block, labeling them by name.
If any blocks are continuations of previously named blocks,
print them separately in the order they appear.
Print LLFE reference literally, e.g. `<<example>>`, rather than expanded.

```{.lfe name="print-code"}
(defun print-code (filename)
  "Given a literate LFE `filename`, print and label each code block therein.
Print all code blocks separately, even if they are continuations."
  (print-sections (all-code (read-file filename))))
```

#### print-concatenated-code/1
Perform similarly to [`print-code/1`](#print-code1),
but concatenate any continued code blocks.

```{.lfe name="print-concatenated-code"}
(defun print-concatenated-code (filename)
  "Given a literate LFE `filename`, print and label each code block therein,
concatenating any continuations."
  (print-sections (concat-sections (all-code (read-file filename)))))
```

#### print-expanded-code/1
Like [`print-concatenated-code/1`](#print-concatenated-code1),
concatenate continued code blocks before printing,
but also expand any LLFE references in-place.

```{.lfe name="print-expanded-code"}
(defun print-expanded-code (filename)
  "Given a literate LFE `filename`, print and label each code block therein,
concatenating any continuations and expanding any references."
  (-> (all-code (read-file filename))
      (concat-sections)
      (expand-all-sections)
      (expand-all-sections)
      (expand-all-sections)
      (expand-all-sections)
      (print-sections)))
```

#### print-unescaped-code/1
Like [`print-expanded-code/1`](#print-expanded-code1), concatenate and expand
code blocks, but also call `unescape/1` on the body of each one.

```{.lfe name="print-unescaped-code"}
(defun print-unescaped-code (filename)
  "Given a literate LFE `filename`, print and label each code block therein,
concatenating continuations, expanding references and unescaping `\<<`."
  (-> (all-code (read-file filename))
      (concat-sections)
      (expand-all-sections)
      (unescape-sections)
      (print-sections)))
```

#### print-file-sections/1
Just like [`print-unescaped-code/1`](#print-unescaped-code1),
but only print sections whose names have the prefix, `file:`, i.e.
blocks that are to be tangled to files.

```{.lfe name="print-file-sections"}
(defun print-file-sections (filename)
  "Given a literate LFE `filename`, print and label each code block therein
whose name has the prefix, `file:`, concatenating continuations,
expanding references and unescaping `\<<`."
  (-> (all-code (read-file filename))
      (concat-sections)
      (expand-all-sections)
      (unescape-sections)
      (file-sections)
      (print-sections)))
```


### Parsing Code Blocks
```{.lfe name="code blocks"}
(defun collect-to-eol (input)
  (case (lists:splitwith #'not-newline?/1 input)
    (`#(,line [10 . ,rest]) `#(,line ,rest))
    (`#(,line ,rest)        `#(,line ,rest))))

(defun collect-to-fence (input) (collect-to-fence input ""))

(defun collect-to-fence
  ([""                        acc] `#(,(lists:reverse acc) ""))
  ;; 10 = \n
  ([`(10 #\` #\` #\` . ,rest) acc] `#(,(lists:reverse acc) ,rest))
  ([`(,c . ,rest)             acc] (collect-to-fence rest (cons c acc))))

(defun all-code (input) (all-code input ""))

(defun all-code
  ([""                 acc] (lists:reverse acc))
  ([`(10 #\` #\` #\` . ,rest) acc]
   (let* ((`#(,attr ,rest1)  (collect-to-eol rest))
          (`#(match [,name]) (match-name attr))
          (`#(,code ,rest2)  (collect-to-fence rest1)))
     (all-code rest2 `[#(,name ,code) . ,acc])))
  ([`(,_ . ,rest)             acc] (all-code rest acc)))
```

### `noweb`-style Replacement
```{.lfe name="noweb-style replacement"}
(defun collect-to-replacement-open (line)
  (collect-to-replacement-open line []))

(defun collect-to-replacement-open
  (["" acc]
   `#(,(lists:reverse acc) ""))
  ([`(#\\ #\< #\< . ,rest) acc]
   (collect-to-replacement-open rest (++ "\<<\\" acc)))
  ([`(#\< #\< . ,rest) acc]
   `#(,(lists:reverse acc) ,rest))
  ([`(,c . ,rest) acc]
   (collect-to-replacement-open rest (cons c acc))))

(defun collect-to-replacement-close (input)
  (collect-to-replacement-close input []))

(defun collect-to-replacement-close
  ([""                 acc] `#(,(lists:reverse acc) ""))
  ([`(#\> #\> . ,rest) acc] `#(,(lists:reverse acc) ,rest))
  ([`(,c . ,rest)      acc] (collect-to-replacement-close rest (cons c acc))))
```

### Sections
```{.lfe name="sections"}
(defun concat-sections (sections)
  (flet ((join-section (key)
                       `#(,key ,(unlines (proplists:get_all_values key sections)))))
    (lists:map #'join-section/1 (proplists:get_keys sections))))

(defun split-section (line)
  (case (collect-to-replacement-open line)
    (`#(,_ "") 'nil)
    (`#(,prefix ,rest)
     (let ((`#(,padded-name ,suffix) (collect-to-replacement-close rest)))
       `#(,(string:strip padded-name) ,prefix ,suffix)))))

(defun expand-sections (code sections) (expand-sections code sections []))

(defun expand-sections
  ([""   _sections acc] (unlines (lists:reverse acc)))
  ([code sections  acc]
   (let ((`#(,line ,rest) (collect-to-eol code)))
     (case (split-section line)
       ('nil (expand-sections rest sections (cons line acc)))
       (`#(,name ,prefix ,suffix)
        (case (proplists:get_value name sections)
          ('undefined
           (io:fwrite "Warning: code section named ~p not found.~n" `[,name])
           (expand-sections rest sections (cons (++ prefix suffix) acc)))
          (code-to-insert
           (-> (lists:map (lambda (x) (++ prefix x suffix)) (lines code-to-insert))
               (unlines)
               (cons acc)
               (->> (expand-sections rest sections))))))))))

(defun expand-all-sections (sections)
  (lists:map
    (match-lambda
      ([`#(,name ,code)]
       `#(,name ,(expand-sections code sections))))
    sections))
```

### Inspecting Files
```{.lfe name="inspecting files"}
<<changed-files>>

<<existing-files>>

<<modified-times>>

<<modified-time>>
```

#### changed-files/1

```{.lfe name="changed-files"}
(defun changed-files (a b)
  (lists:filter
    (lambda (x) (=/= (proplists:get_value x a) (proplists:get_value x b)))
    (proplists:get_keys a)))
```

#### exisiting-files/1

```{.lfe name="existing-files"}
(defun existing-files (files)
  "Given a list of `files`, return the sublist for which `filelib:is_file/1` holds."
  (lists:filter #'filelib:is_file/1 files))
```

#### modified-times/1
Call [`modified-time/1`] and return a tuple of the form,
`` `#(,file ,modified-time) ``, for each file in a given list of `files`.

```{.lfe name="modified-times"}
(defun modified-times (files)
  "Call [[modified-time/1]] on each file in a given list of `files`.
For each file, return a tuple of the form `` `#(,file ,modified-time) ``."
  (lists:map (lambda (file) `#(,file ,(modified-time file))) files))
```

[`modified-time/1`]: #modified-time1


#### modified-time/1
Given a `filename`, retrieve information about it, using [`file:read_file_info/1`],
and return the last time the file was written.

```{.lfe name="modified-time"}
(defun modified-time (filename)
  "Given a `filename`, return the last time the file was written."
  (let ((`#(ok ,info) (file:read_file_info filename)))
    (file_info-mtime info)))
```

[`file:read_file_info/1`]: http://www.erlang.org/doc/man/file.html#read_file_info-1


### Reading Files
```{.lfe name="reading files"}
(defun read-file (filename)
  (case (file:read_file filename)
    (`#(ok ,binary) (binary_to_list binary))
    (`#(error ,reason)
     (io:fwrite "Failed to read file (~s): ~s~n" `[,filename ,reason])
     (error `#(read_file ,filename ,reason)))))

(defun file-sections (sections)
  (lists:filtermap
    (match-lambda
      ([`#(,(= `(#\f #\i #\l #\e #\: . ,_) name) ,code)]
       `#(true #(,name ,code)))
      ([_] 'false))
    sections))
```

### Processing Files
```{.lfe name="processing files"}
(defun process-files (files)
  (lists:reverse (lists:flatmap #'process-file/1 files)))

(defun process-file (filename)
  (let* ((base-dir          (filename:dirname filename))
         (concatenated-code (concat-sections (all-code (read-file filename))))
         (expanded-code     (-> concatenated-code
                                (expand-all-sections)
                                (expand-all-sections)
                                (expand-all-sections)
                                (expand-all-sections)))
         (files (file-sections (unescape-sections expanded-code))))
    (write-file-sections base-dir files)))
```

### Writing Files
```{.lfe name="writing files"}
(defun write-file (base-dir filename contents)
  (let ((filename* (file-name base-dir filename)))
    (case (file:write_file filename* (++ contents "\n"))
      ('ok filename*)
      (`#(error ,reason)
       (io:fwrite (++ "Error: Failed to write file (~s): ~s. "
                      "(LLFE doesn't create directories, so you may need to "
                      "create one.)~n")
                  `[,filename* ,reason])))))

;; TODO: handle padline option
(defun write-file-sections (base-dir files)
  (-> (match-lambda
        ([`#((#\f #\i #\l #\e #\: . ,filename) ,contents)]
         (write-file base-dir filename contents)))
      (lists:map files)
      (lists:reverse)))
```

### Watching Files
```{.lfe name="watching files"}
(defun watch (files f) (watch files f []))

(defun watch (files f state)
  (let* ((modified-times (modified-times (existing-files files)))
         (changed-files  (changed-files modified-times state)))
    (if (> (length changed-files) 0)
      (apply f `[,changed-files])
      'noop)
    (timer:sleep (timer:seconds 1))
    (watch files f modified-times)))
```

### Internal Functions

Predicates.
```{.lfe name="internal functions"}
(defun help? (x)
  "Return `true` iff `x` is one of \"help\", \"-h\", \"-help\" or \"\"--help\"."
  (lists:member x '["help" "-h" "-help" "--help"]))

(defun not-newline?
  "Given a character, return `true` iff it iss not `\\n`."
  ([10] 'false)
  ([_]  'true))
```

Resolving absolute paths.
```{.lfe name="internal functions"}

(defun file-name (base-dir filename)
  "Given a `base-dir`ectory and a `filename`, return an absolute path.
The result will be formatted in a way that is accepted by the command shell and
native applications on the current platform."
  (filename:nativename (filename:absname_join base-dir filename)))
```

Parsing header options.
```{.lfe name="internal functions"}

(defun match-name (input)
  (re:run input "name=\"(?<name>[^\"]+)\"" '[#(capture [name] list)]))
```

Haskell-inspired string manipulation.
```{.lfe name="internal functions"}

(defun lines (string)
  "Break a string up into a list of strings at newline characters.
The resulting strings do not contain newlines."
  (re:split string "\n" '[#(return list)]))

(defun unlines (strings)
  "Joins lines, after appending a terminating newline to each.
[[unlines/1]] is an inverse operation to [[lines/1]]."
  (string:join strings "\n"))
```

### unescape/1
Unescaping `<<`.

```{.lfe name="internal functions"}

(defun unescape (code)
  "Given the contents of a code block, replace any `\"\\<<\"` with `\"\<<\"`."
  (re:replace code "\\\\\<<" "\<<" '[global #(return list)]))
```

### unescape-sections/1

```{.lfe name="internal functions"}

(defun unescape-sections (sections)
  "Given a list of sections, call [[unescape/1]] on each code block."
  (lists:map
    (match-lambda ([`#(,name ,code)] `#(,name ,(unescape code))))
    sections))
```

### Main Entry Point
```{.lfe name="main entry point"}
(defun main
  (['()] (usage))
  ([`("watch" . ,files)]
   (watch files
          (lambda (changed-files)
            (flet ((print (x) (io:fwrite "~s~n" `[,x])))
              (io:fwrite "\n~s\n" `[,(string:centre " Processing " 30 #\-)])
              (lists:foreach #'print/1 changed-files)
              (io:fwrite "\n~s\n" `[,(string:centre " Output " 30 #\-)])
              (lists:foreach #'print/1 (process-files changed-files))))))
  ([`("print-code"              ,file)] (print-code file))
  ([`("print-concatenated-code" ,file)] (print-concatenated-code file))
  ([`("print-expanded-code"     ,file)] (print-expanded-code file))
  ([`("print-unescaped-code"    ,file)] (print-unescaped-code file))
  ([`("print-file-sections"     ,file)] (print-file-sections file))
  ([args]
   (if (lists:any #'help?/1 args)
     (usage)
     (process-files args))))
```

In LFE scripts, `script-args` is bound to the list of command line arguments.
Now that the script defined, run it by calling `main/1` with `script-args`.
In other words, "[Just do it!]"

```{.lfe name="just do it"}
(main script-args)
```

[Just do it!]: https://www.youtube.com/watch?v=ZXsQAXx_ao0

### Tangling it All Together
```{.lfe name="llfe"}
;;;===================================================================
;;; Printing
;;;===================================================================

<<printing>>


;;;===================================================================
;;; Code blocks
;;;===================================================================

<<code blocks>>


;;;===================================================================
;;; noweb-style replacement
;;;===================================================================

<<noweb-style replacement>>


;;;===================================================================
;;; Sections
;;;===================================================================

<<sections>>


;;;===================================================================
;;; Inspecting files
;;;===================================================================

<<inspecting files>>


;;;===================================================================
;;; Reading files
;;;===================================================================

<<reading files>>


;;;===================================================================
;;; Processing files
;;;===================================================================

<<processing files>>


;;;===================================================================
;;; Writing files
;;;===================================================================

<<writing files>>


;;;===================================================================
;;; Watching files
;;;===================================================================

<<watching files>>


;;;===================================================================
;;; Internal functions
;;;===================================================================

<<internal functions>>


;;;===================================================================
;;; Main entry point
;;;===================================================================

<<main entry point>>

<<just do it>>

```

## License
[The Unlicense]

```{name="file:UNLICENSE"}
This is free and unencumbered software released into the public domain.

Anyone is free to copy, modify, publish, use, compile, sell, or
distribute this software, either in source code form or as a compiled
binary, for any purpose, commercial or non-commercial, and by any
means.

In jurisdictions that recognize copyright laws, the author or authors
of this software dedicate any and all copyright interest in the
software to the public domain. We make this dedication for the benefit
of the public at large and to the detriment of our heirs and
successors. We intend this dedication to be an overt act of
relinquishment in perpetuity of all present and future rights to this
software under copyright law.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR
OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.

For more information, please refer to <http://unlicense.org/>
```

[The Unlicense]: http://unlicense.org
